## Insertion Sort
```python
def insertionSort(nums):
    for i in range(1, len(nums)):
        j = i - 1
        while j >= 0 and nums[j] > nums[j + 1]:
           
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            j -= 1
    return nums
```

## Binary Search
```python 3
def binarysearch(nums, target):
    low = 0
    high = len(nums) - 1
    while (low <= high):
        mid = (high + low)//2

        if (nums[mid] < target):
            low = mid + 1
            

        if (nums[mid] > target):
            high = mid - 1
            

        if (nums[mid] == target):
            return mid

    return -1

```


## KMP

```python 3
def getnext(self, a, s):
    # length of the array
    # string 
    
    next = [0]*a
    j = 0
        
    next[0] = 0

        
    for i in range(1, len(s)):
        while j > 0 and s[j] != s[i]:
            j = next[j - 1]
            
        if s[j] == s[i]:
            j += 1
        next[i] = j
    return next 

```

## Tree 

### Recursion - preorder 
```python
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        result.append(root.val)
        self.traverse(root.left, result)
        self.traverse(root.right, result)


    def preorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```


### Recursion - inorder
```python
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        self.traverse(root.left, result)
        result.append(root.val)
        self.traverse(root.right, result)


    def inorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```



### Recursion - postorder
```python 
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        self.traverse(root.left, result)
        self.traverse(root.right, result)
        result.append(root.val)


    def postorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```

### traversal - preorder
```python 
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root == None:
            return []

        result = []
        stack = [root]

        while stack:
            node = stack.pop()

            # 中
            result.append(node.val)

            # 右
            if node.right:
                stack.append(node.right)

            # 左
            if node.left:
                stack.append(node.left)

        return result 
```

## traversal - inorder
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if root == None:
            return []

        cur = root 

        stack = []

        result = []

        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left 
            else:
                cur = stack.pop()
                result.append(cur.val)
                cur = cur.right
        
        return result 

```


### traversal - postorder
```python 
class Solution:
    def postorderTraversal(self, root):
        if root == None:
            return []

        result = []
        stack = [root]

        while stack:
            node = stack.pop()

            # 中
            result.append(node.val)

            # 左
            if node.left:
                stack.append(node.left)

            # 右
            if node.right:
                stack.append(node.right)

            

        return result[::-1]
```


### 二叉树层序遍历
```python 
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root == None:
            return []
        results = []

        que = deque([root])

        while que:
            size = len(que)

            result = []

            for _ in range(size):
                node = que.popleft()
                result.append(node.val)
                if node.left:
                    que.append(node.left)

                if node.right:
                    que.append(node.right)
            results.append(result)

        return results
```

## 二叉树回溯模版
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.result = 1

    def getDepth(self, root, depth):
        self.result = max(depth, self.result)

        if root.left == None and root.right == None:
            return 

        if root.left != None:
            depth += 1
            self.getDepth(root.left, depth)
            depth -= 1
        
        if root.right != None:
            depth += 1
            self.getDepth(root.right, depth)
            depth -= 1

            

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0


        self.getDepth(root, 1)

        return self.result

```

## BST specific 模版
```python 3
class Solution:

    def __init__(self):
        self.result = float("inf")
        self.pre = None

    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0
        
        self.getMinimumDifference(root.left)

        if self.pre != None and root != None: 

            differnence = abs(root.val - self.pre.val)

            self.result = min(differnence, self.result)

        self.pre = root

        self.getMinimumDifference(root.right)


        return self.result
```


## 背包问题 (Knapsack problem) - 2D
```python 3
def test_1_wei_bag_problem():
    def test_2_wei_bag_problem1(bag_size, weight, value):
    row = len(weight)
    col = bag_size + 1


    dp = [[0 for _ in range(col)] for _ in range(row)]
    
    # initialization
    for i in range(row):
        dp[i][0] = 0

    for j in range(1, col):
        if weight[0] <= j:
            dp[0][j] = value[0]
    
    # 先遍历物品
    for i in range(1, row):

        cur_weight = weight[i]
        cur_value = value[i]

        for j in range(1, col):
                
            if cur_weight > j:
                # 不放
                dp[i][j] = dp[i - 1][j]
            else:
                # 放 or 不放取最大的
                dp[i][j] = max(dp[i - 1][j - cur_weight] + cur_value, dp[i - 1][j])
    return dp[row - 1][col - 1]
```