## Insertion Sort
```python
def insertionSort(nums):
    for i in range(1, len(nums)):
        j = i - 1
        while j >= 0 and nums[j] > nums[j + 1]:
           
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            j -= 1
    return nums
```

## Binary Search
```python 3
def binarysearch(nums, target):
    low = 0
    high = len(nums) - 1
    while (low <= high):
        mid = (high + low)//2

        if (nums[mid] < target):
            low = mid + 1
            

        if (nums[mid] > target):
            high = mid - 1
            

        if (nums[mid] == target):
            return mid

    return -1

```


## KMP

```python 3
def getnext(self, a, s):
    # length of the array
    # string 
    
    next = [0]*a
    j = 0
        
    next[0] = 0

        
    for i in range(1, len(s)):
        while j > 0 and s[j] != s[i]:
            j = next[j - 1]
            
        if s[j] == s[i]:
            j += 1
        next[i] = j
    return next 

```

## Tree 

### Recursion - preorder 
```python
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        result.append(root.val)
        self.traverse(root.left, result)
        self.traverse(root.right, result)


    def preorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```


### Recursion - inorder
```python
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        self.traverse(root.left, result)
        result.append(root.val)
        self.traverse(root.right, result)


    def inorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```



### Recursion - postorder
```python 
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        self.traverse(root.left, result)
        self.traverse(root.right, result)
        result.append(root.val)


    def postorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```

### traversal - preorder
```python 
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root == None:
            return []

        result = []
        stack = [root]

        while stack:
            node = stack.pop()

            # 中
            result.append(node.val)

            # 右
            if node.right:
                stack.append(node.right)

            # 左
            if node.left:
                stack.append(node.left)

        return result 
```

## traversal - inorder
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if root == None:
            return []

        cur = root 

        stack = []

        result = []

        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left 
            else:
                cur = stack.pop()
                result.append(cur.val)
                cur = cur.right
        
        return result 

```


### traversal - postorder
```python 
class Solution:
    def postorderTraversal(self, root):
        if root == None:
            return []

        result = []
        stack = [root]

        while stack:
            node = stack.pop()

            # 中
            result.append(node.val)

            # 左
            if node.left:
                stack.append(node.left)

            # 右
            if node.right:
                stack.append(node.right)

            

        return result[::-1]
```


### 二叉树层序遍历
```python 
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root == None:
            return []
        results = []

        que = deque([root])

        while que:
            size = len(que)

            result = []

            for _ in range(size):
                node = que.popleft()
                result.append(node.val)
                if node.left:
                    que.append(node.left)

                if node.right:
                    que.append(node.right)
            results.append(result)

        return results
```