## Insertion Sort
```python
def insertionSort(nums):
    for i in range(1, len(nums)):
        j = i - 1
        while j >= 0 and nums[j] > nums[j + 1]:
           
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            j -= 1
    return nums
```
## Bubble Sort
```python 
def bubble_sort(nums):
    n = len(nums)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums
```

## Insertion Sort
```python
def partition(nums, left, right):
    i = left
    j = right 
    while i < j:
        # find the first number which is smaller than pivot
        while i < j and nums[j] >= nums[left]:
            j -= 1
        # find the first number which is bigger than pivot 
        while i < j and nums[i] <= nums[left]:
            i += 1
        
        nums[i], nums[j] = nums[j], nums[i]
        
    nums[left], nums[i] = nums[i], nums[left]
    
    return i        
    
    
    
    
def quick_sort(nums, left, right):
    if left >= right:
        return 
    
    pivot = partition(nums, left, right)
    quick_sort(nums, left, pivot - 1)
    quick_sort(nums, pivot + 1, right)
    
```

## Binary Search
```python 3
def binarysearch(nums, target):
    low = 0
    high = len(nums) - 1
    while (low <= high):
        mid = (high + low)//2

        if (nums[mid] < target):
            low = mid + 1
            

        if (nums[mid] > target):
            high = mid - 1
            

        if (nums[mid] == target):
            return mid

    return -1

```


## KMP

```python 3
def getnext(self, a, s):
    # length of the array
    # string 
    
    next = [0]*a
    j = 0
        
    next[0] = 0

        
    for i in range(1, len(s)):
        while j > 0 and s[j] != s[i]:
            j = next[j - 1]
            
        if s[j] == s[i]:
            j += 1
        next[i] = j
    return next 

```

## Tree 

### Recursion - preorder 
```python
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        result.append(root.val)
        self.traverse(root.left, result)
        self.traverse(root.right, result)


    def preorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```


### Recursion - inorder
```python
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        self.traverse(root.left, result)
        result.append(root.val)
        self.traverse(root.right, result)


    def inorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```



### Recursion - postorder
```python 
class Solution:
    def traverse(self, root, result):
        if root == None:
            return 
        self.traverse(root.left, result)
        self.traverse(root.right, result)
        result.append(root.val)


    def postorderTraversal(self, root):
        result = []
        if root == None:
            return result
        
        self.traverse(root, result)
        return result
```

### traversal - preorder
```python 
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root == None:
            return []

        result = []
        stack = [root]

        while stack:
            node = stack.pop()

            # 中
            result.append(node.val)

            # 右
            if node.right:
                stack.append(node.right)

            # 左
            if node.left:
                stack.append(node.left)

        return result 
```

## traversal - inorder
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        if root == None:
            return []

        cur = root 

        stack = []

        result = []

        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left 
            else:
                cur = stack.pop()
                result.append(cur.val)
                cur = cur.right
        
        return result 

```


### traversal - postorder
```python 
class Solution:
    def postorderTraversal(self, root):
        if root == None:
            return []

        result = []
        stack = [root]

        while stack:
            node = stack.pop()

            # 中
            result.append(node.val)

            # 左
            if node.left:
                stack.append(node.left)

            # 右
            if node.right:
                stack.append(node.right)

            

        return result[::-1]
```


### 二叉树层序遍历
```python 
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root == None:
            return []
        results = []

        que = deque([root])

        while que:
            size = len(que)

            result = []

            for _ in range(size):
                node = que.popleft()
                result.append(node.val)
                if node.left:
                    que.append(node.left)

                if node.right:
                    que.append(node.right)
            results.append(result)

        return results
```

## 二叉树回溯模版
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.result = 1

    def getDepth(self, root, depth):
        self.result = max(depth, self.result)

        if root.left == None and root.right == None:
            return 

        if root.left != None:
            depth += 1
            self.getDepth(root.left, depth)
            depth -= 1
        
        if root.right != None:
            depth += 1
            self.getDepth(root.right, depth)
            depth -= 1

            

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0


        self.getDepth(root, 1)

        return self.result

```
## BST 单层逻辑
```python 3
if (root->val > key) root->left = deleteNode(root->left, key);
if (root->val < key) root->right = deleteNode(root->right, key);
return root 
```
## BST specific 模版
```python 3
class Solution:

    def __init__(self):
        self.result = float("inf")
        self.pre = None

    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0
        
        self.getMinimumDifference(root.left)

        if self.pre != None and root != None: 

            differnence = abs(root.val - self.pre.val)

            self.result = min(differnence, self.result)

        self.pre = root

        self.getMinimumDifference(root.right)


        return self.result
```



![](./Image/Knapsack_problem.png)
## 01背包问题 (Knapsack problem) - 1D
```python 3

def test_1_wei_bag_problem():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4
    # 初始化: 全为0
    dp = [0] * (bag_weight + 1)

    # 先遍历物品, 再遍历背包容量 => 这个顺序很重要，不能换
    for i in range(len(weight)):
        for j in range(bag_weight, weight[i] - 1, -1):
            # 递归公式
            # 比起 2D 的数组相当于把 [i - 1] 删除了。做了一个直接拷贝的动作。
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])


    return dp[-1]
```

## 01背包问题 (Knapsack problem) - 2D
```python 3
def test_1_wei_bag_problem():
    def test_2_wei_bag_problem1(bag_size, weight, value):
    row = len(weight)
    col = bag_size + 1


    dp = [[0 for _ in range(col)] for _ in range(row)]
    
    # initialization
    for i in range(row):
        dp[i][0] = 0

    for j in range(1, col):
        if weight[0] <= j:
            dp[0][j] = value[0]
    
    # 先遍历物品
    for i in range(1, row):

        cur_weight = weight[i]
        cur_value = value[i]

        for j in range(1, col):
                
            if cur_weight > j:
                # 不放
                dp[i][j] = dp[i - 1][j]
            else:
                # 放 or 不放取最大的
                dp[i][j] = max(dp[i - 1][j - cur_weight] + cur_value, dp[i - 1][j])
    return dp[row - 1][col - 1]
```

## 完全背包问题 (Knapsack problem) - 1D 
```python 3

def test_1_wei_bag_problem():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4
    # 初始化: 全为0
    dp = [0] * (bag_weight + 1)

    # 先遍历物品, 再遍历背包容量 => 这个顺序很重要，不能换
    for i in range(len(weight)):
        for j in range(weight[i], bag_weight + 1):
            # 递归公式
            # 比起 2D 的数组相当于把 [i - 1] 删除了。做了一个直接拷贝的动作。
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])


    return dp[-1]
```

## 完全背包 - 1D - 组合
先物品，再背包
```python 
class Solution:
    def combination(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)

        # index and its meaning 
        # i => amount, dp[i] => # of combo
        
        # initialization 
        dp[0] = 1
        # dp relation:
        # dp[j] += dp[j - coins[i]]

        for i in range(len(coins)):
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]]


        return dp[amount]
```
## 完全背包 - 1D - 排列
先背包，再物品
```python 
class Solution:
    def permutation(self, nums: List[int], target: int) -> int:

        dp = [0] * (target + 1)

        # initializtaion 
        dp[0] = 1

        # how to traverse (order)
        # state transformation 
        for j in range(1, target + 1):
            for i in range(len(nums)):
                if j >= nums[i]:
                    dp[j] += dp[j - nums[i]] 


        return dp[target]
```